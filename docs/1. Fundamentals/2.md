# Bits, Nibbles, Bytes and Words

It would be unusual for us to want to exchange single bits. We could exchange data in groups of 4 bits, this is called a nibble and is very unusual. However, the first production microprocessor (4004) was a 4-bit computer.

When we began exchanging characters first, we did so with a standard called ASCII, the American Standard Code for Information Interchange. Work began on this in 1960 with the American Standards Association's (ASA) X3.2 subcommittee and the standards were released in 1963, revised in 1967 and 1986. ASCII was developed from early telegraphic codes, and its first commercial use was as a 7-bit teleprinter code. 7 bits gives us 2^7 or 128 possible characters.

- 26 Capital (65-90) and 26 Lower Case (97-122)
- 10 Numbers (48-57)
- 32+1 Control Characters (0-31, 127)

It may seem strange to use 7 bits, but we needed some other things like start and stop bits and our early serial chips could only cope with 10 bits. Eventually extended ASCII was developed and includes definitions for 2^8 or 256 characters. The generation of microprocessors from the 8008 onward used 8 bits internally, a byte. 

Some early mainframes and mini computers used 12 bits!

As symbol lengths went above 8 bits, we used the term word. We can have 16, 32, 64 bit words.

# Unicode
ASCII was very limited with no support for languages, symbols etc. Unicode was a solution developed in the late 1980s and standardized in 1991. Unicode standardized numeric representations for symbols required for international writing. Unicode is backward compatible with ASCII (UTF-8). A Unicode character is represented by the format U+ followed by the character code in HEX. For example, U+0041 is the ASCII character A. The most recent specification for UNICODE is Unicode v.6.

ASCII has now been superseded by UNICODE. Do some background reading on ASCII and UNICODE and ensure you understand it.

# Errors and Parity
Communications links can be affected by electrical noise and now and then, a spike of noise can cause a bit error in a circuit.

<figure>
<img src = "https://jor-donegal.github.io/pnt26/images/fig5.png">
<figcaption>Fig 5. Noise.</figcaption>
</figure>

The noise voltage will be superimposed on the signal, the receiver will be unable to distinguish between a symbol caused by noise and the original intended signal.

To counteract the effect of noise causing a bit error, we use parity. We add up all the bits in the original signal. There were four 1â€™s and that is an even number, so we could make our parity value 0. If we added them up and they made an odd number, we could make our parity value 1. We can then add a parity bit to the end of our data, before the stop bit.

Parity will allow us to find any single bit error in a character. It will not allow us to detect two or more bits of error (why?).

# Parallel Links
Another strategy for data communications is to pass a byte (8 bits) or a word (16 or 32 bits) at a time. Imagine two computers have a connection with eight data lines, D0-D7. Now I can transmit a byte at a time. If the link speed is the same as serial, I now have eight-times the data transfer rate. This would seem to be a far better solution than serial.

Unfortunately, once our links are very fast, we start running into problems. Every one of the eight links must have the same signal transfer characteristics, or we end up with bits arriving out of alignment.

Most modern systems use multiple serial links instead of parallel links.

<figure>
<img src = "https://jor-donegal.github.io/pnt26/images/fig6.png">
<figcaption>Fig 6. Parallel Links.</figcaption>
</figure>